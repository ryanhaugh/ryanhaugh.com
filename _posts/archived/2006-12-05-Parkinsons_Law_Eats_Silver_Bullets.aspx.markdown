---
layout: post
title: "Parkinson's Law Eats Silver Bullets"
date: 2006-12-05 -0800
comments: true
disqus_identifier: 18156
categories: []
---
![Silver Bullet: From
http://www.tejasthumpcycles.com/Parts/LeversGripsctrls/Silver\_Bullet/Silver\_Bullet\_Shift\_Brake.jpg](http://haacked.com/images/haacked_com/WindowsLiveWriter/TradeoffsWhenMinimizingTheImpactOfChange_1D54/Silver_Bullet_thumb%5B1%5D.jpg)
In his essay [No Silver Bullet: Essence and Accidents of Software
Engineering](http://www-inst.eecs.berkeley.edu/~maratb/readings/NoSilverBullet.html "No Silver Bullet"),
Fred Brooks makes the following postulate:

> There is no single development, in either technology or in management
> technique, that by itself promises even one order-of-magnitude
> improvement in productivity, in reliability, in simplicity.

This “law” was recently invoked by [Joel
Spolsky](http://www.joelonsoftware.com/ "Joel Spolsky") in his post
[Lego
Blocks](http://www.joelonsoftware.com/items/2006/12/05.html "Lego Blocks"),
which prompted an [interesting
rebuttal](http://wesnerm.blogs.com/net_undocumented/2006/12/lego_programmin.html "Lego Blocks")
by [Wesner Moise](http://wesnerm.blogs.com/ "Wesner Moise's Blog").

> **That assertion turns out to be pure nonsense, amply disproven by
> numerous advances in IDEs, languages, frameworks,
> componentization over the past few decades.** Our expectations of
> software and our ability have risen. A year of work takes a month or a
> month of work takes a day.

Whether you agree with Wesner’s position or not comes down to how you
define a *single development*.  It could be argued that the order of
magnitude improvement we have now is a cumulative result of multiple
improvements.

Regardless, perhaps a more lasting way to rephrase this assertion is to
state that no single technology, development, or management technique
will produce by itself an order-of magnitude **improvement in meeting
current business needs**.

In other words, sure we can produce an order-of-magnitude more
productivity now than we could before, but changing business climates
and consumer needs have also increased by an order-of-magnitude. Just
compare a modern game like
[Oblivion](http://www.elderscrolls.com/games/oblivion_overview.htm "Oblivion")
to an older game like [Ultima
I](http://www.uo.com/archive/ultima1/ "Ultima I").

[![Oblivion
Screenshot](http://haacked.com/images/haacked_com/WindowsLiveWriter/ParkinsonsLawEatsSilverBullets_C3B8/Oblivion762892_thumb.jpg)](http://haacked.com/images/haacked_com/WindowsLiveWriter/ParkinsonsLawEatsSilverBullets_C3B8/Oblivion7628922.jpg)
[![Ultima
Screenshot](http://haacked.com/images/haacked_com/WindowsLiveWriter/ParkinsonsLawEatsSilverBullets_C3B8/Ultima1_thumb1.gif)](http://haacked.com/images/haacked_com/WindowsLiveWriter/ParkinsonsLawEatsSilverBullets_C3B8/Ultima13.gif)

In a way, this is [Parkinson’s
Law](http://en.wikipedia.org/wiki/Parkinson’s_law "Parkinson’s Law on Wikipedia")
at work:

> work expands so as to fill the time available for its completion.

I’ll restate it to apply to software engineering:

> Business needs and feature requirements increase to fill in the
> productivity gains due to silver bullets.

What do you think, is that sufficiently original to call it *Haack’s
Law*? ![Wink](http://haacked.com/Images/emotions/smiley-wink.gif)

In any case, I think Joel’s original point still stands. **Building
software *to meet current needs*, will always be hard.**  When you think
about it, the dreams of building software with lego-like blocks has been
realized. But only for those who need to write software that meets the
needs of users in the 1960s.  For modern needs, it remains challenging.

